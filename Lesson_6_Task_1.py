"""
1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах
в рамках первых трех уроков. Проанализировать результат и определить программы
с наиболее эффективным использованием памяти.

Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
a. выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
b. написать 3 варианта кода (один у вас уже есть);
проанализировать 3 варианта и выбрать оптимальный;
c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом.
Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
d. написать общий вывод: какой из трёх вариантов лучше и почему.
"""

"""
Домашнее задание №2. Задача 2. Посчитать четные и нечетные цифры введенного натурального числа.
Например, если введено число 34560, в нем 3 четные цифры (4, 6 и 0) и 2 нечетные (3 и 5).
"""

import sys


print('Версия и разрядность ОС и интерпретоатора Python')
print(sys.version, sys.platform)
#3.8.5 (default, Sep  3 2020, 21:29:08) [MSC v.1916 64 bit (AMD64)] win32
print()

#функция для определения памяти, выделенной под переменные
def show_memory(var):
    sum_memory = 0

    print(f'Переменная типа {var.__class__}, размера {sys.getsizeof(var)}, содержимое {var}')
    spam = sys.getsizeof(var)

    if hasattr(var, '__iter__'): #является ли var итерируемым объектом
        if hasattr(var,'items'): #является ли var словарем
            for el in var.items():
                spam += show_memory(el)
        elif not isinstance(var, str): #var итерируемый объект, но не строка
            for el in var:
                spam += show_memory(el)
    sum_memory += spam

    return sum_memory

"""
Проанализируем следующие алгоритмы (см. Lesson_4_Task_1)
"""
#Алгоритм №1 (определяем четность самого числа: если число четно/нечетно, то последняя цифра четная/нечетная)
num = '11222'
num = int(num)
n_odd = 0
n_even = 0
while num > 0:
    if num % 2 == 0:
        n_even += 1
    else:
        n_odd += 1
    num = num // 10

#анализ алгоритма №1
list_of_vars = [num, n_even, n_odd]
memory = sum([show_memory(var) for var in list_of_vars])
print(f'Используемая память первого алгоритма: {memory}')
print()
"""
Переменная типа <class 'int'>, размера 24, содержимое 0
Переменная типа <class 'int'>, размера 28, содержимое 3
Переменная типа <class 'int'>, размера 28, содержимое 2
Используемая память первого алгоритма: 80
"""


#Алгоритм №2 (определяем четность каждой цифры)
num = '11222'
n_odd = 0
n_even = 0
for i in num:
    if int(i) % 2 == 0:
        n_even += 1
    else:
        n_odd += 1

# анализ алгоритма №2
list_of_vars = [num, n_even, n_odd]
memory = sum([show_memory(var) for var in list_of_vars])
print(f'Используемая память второго алгоритма: {memory}')
print()
"""
Переменная типа <class 'str'>, размера 54, содержимое 11222
Переменная типа <class 'int'>, размера 28, содержимое 3
Переменная типа <class 'int'>, размера 28, содержимое 2
Используемая память второго алгоритма: 110
"""

#Алгоритм №3 (определяем принадлежность цифры числа заранее подготовленному списку)
num='11222'
even_digits = '02468'
n_odd = 0
n_even = 0
for i in num:
    if i in even_digits:
        n_even += 1
    else:
        n_odd += 1

# анализ алгоритма №3
list_of_vars = [num, even_digits, n_even, n_odd]
memory = sum([show_memory(var) for var in list_of_vars])
print(f'Используемая память третьего алгоритма: {memory}')
"""
Переменная типа <class 'str'>, размера 54, содержимое 11222
Переменная типа <class 'str'>, размера 54, содержимое 02468
Переменная типа <class 'int'>, размера 28, содержимое 3
Переменная типа <class 'int'>, размера 28, содержимое 2
Используемая память третьего алгоритма: 164
"""

"""
Выводы: 
1. Использование строк в алгоритмах существенно повышает объем памяти по сравнению с использованием чисел.
2. Чем больше памяти выделено под переменные, тем быстрее работает алгоритм 
(вывод на основе сравнения результатов из Lesson_4_Task_1 и Lesson_6_Task_1).
3. Программа с наиболее эффективным использованием памяти -- алгоритм №1.
"""
